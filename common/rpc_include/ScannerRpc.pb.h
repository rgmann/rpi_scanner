// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ScannerRpc.proto

#ifndef PROTOBUF_ScannerRpc_2eproto__INCLUDED
#define PROTOBUF_ScannerRpc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ScannerRpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ScannerRpc_2eproto();
void protobuf_AssignDesc_ScannerRpc_2eproto();
void protobuf_ShutdownFile_ScannerRpc_2eproto();

class Request;
class Request_ScannerPoint;
class Request_RasterOptions;
class Response;

enum Request_ScannerMode {
  Request_ScannerMode_IDLE = 0,
  Request_ScannerMode_POINT = 1,
  Request_ScannerMode_RASTER = 2
};
bool Request_ScannerMode_IsValid(int value);
const Request_ScannerMode Request_ScannerMode_ScannerMode_MIN = Request_ScannerMode_IDLE;
const Request_ScannerMode Request_ScannerMode_ScannerMode_MAX = Request_ScannerMode_RASTER;
const int Request_ScannerMode_ScannerMode_ARRAYSIZE = Request_ScannerMode_ScannerMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_ScannerMode_descriptor();
inline const ::std::string& Request_ScannerMode_Name(Request_ScannerMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_ScannerMode_descriptor(), value);
}
inline bool Request_ScannerMode_Parse(
    const ::std::string& name, Request_ScannerMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_ScannerMode>(
    Request_ScannerMode_descriptor(), name, value);
}
// ===================================================================

class Request_ScannerPoint : public ::google::protobuf::Message {
 public:
  Request_ScannerPoint();
  virtual ~Request_ScannerPoint();

  Request_ScannerPoint(const Request_ScannerPoint& from);

  inline Request_ScannerPoint& operator=(const Request_ScannerPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_ScannerPoint& default_instance();

  void Swap(Request_ScannerPoint* other);

  // implements Message ----------------------------------------------

  Request_ScannerPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_ScannerPoint& from);
  void MergeFrom(const Request_ScannerPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double phi = 1;
  inline bool has_phi() const;
  inline void clear_phi();
  static const int kPhiFieldNumber = 1;
  inline double phi() const;
  inline void set_phi(double value);

  // required double theta = 2;
  inline bool has_theta() const;
  inline void clear_theta();
  static const int kThetaFieldNumber = 2;
  inline double theta() const;
  inline void set_theta(double value);

  // @@protoc_insertion_point(class_scope:ScannerRpc.Request.ScannerPoint)
 private:
  inline void set_has_phi();
  inline void clear_has_phi();
  inline void set_has_theta();
  inline void clear_has_theta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double phi_;
  double theta_;
  friend void  protobuf_AddDesc_ScannerRpc_2eproto();
  friend void protobuf_AssignDesc_ScannerRpc_2eproto();
  friend void protobuf_ShutdownFile_ScannerRpc_2eproto();

  void InitAsDefaultInstance();
  static Request_ScannerPoint* default_instance_;
};
// -------------------------------------------------------------------

class Request_RasterOptions : public ::google::protobuf::Message {
 public:
  Request_RasterOptions();
  virtual ~Request_RasterOptions();

  Request_RasterOptions(const Request_RasterOptions& from);

  inline Request_RasterOptions& operator=(const Request_RasterOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_RasterOptions& default_instance();

  void Swap(Request_RasterOptions* other);

  // implements Message ----------------------------------------------

  Request_RasterOptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_RasterOptions& from);
  void MergeFrom(const Request_RasterOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float min_phi = 1;
  inline bool has_min_phi() const;
  inline void clear_min_phi();
  static const int kMinPhiFieldNumber = 1;
  inline float min_phi() const;
  inline void set_min_phi(float value);

  // optional float max_phi = 2;
  inline bool has_max_phi() const;
  inline void clear_max_phi();
  static const int kMaxPhiFieldNumber = 2;
  inline float max_phi() const;
  inline void set_max_phi(float value);

  // optional float min_theta = 3;
  inline bool has_min_theta() const;
  inline void clear_min_theta();
  static const int kMinThetaFieldNumber = 3;
  inline float min_theta() const;
  inline void set_min_theta(float value);

  // optional float max_theta = 4;
  inline bool has_max_theta() const;
  inline void clear_max_theta();
  static const int kMaxThetaFieldNumber = 4;
  inline float max_theta() const;
  inline void set_max_theta(float value);

  // optional int32 measure_delay_ms = 5;
  inline bool has_measure_delay_ms() const;
  inline void clear_measure_delay_ms();
  static const int kMeasureDelayMsFieldNumber = 5;
  inline ::google::protobuf::int32 measure_delay_ms() const;
  inline void set_measure_delay_ms(::google::protobuf::int32 value);

  // optional float increment = 6;
  inline bool has_increment() const;
  inline void clear_increment();
  static const int kIncrementFieldNumber = 6;
  inline float increment() const;
  inline void set_increment(float value);

  // @@protoc_insertion_point(class_scope:ScannerRpc.Request.RasterOptions)
 private:
  inline void set_has_min_phi();
  inline void clear_has_min_phi();
  inline void set_has_max_phi();
  inline void clear_has_max_phi();
  inline void set_has_min_theta();
  inline void clear_has_min_theta();
  inline void set_has_max_theta();
  inline void clear_has_max_theta();
  inline void set_has_measure_delay_ms();
  inline void clear_has_measure_delay_ms();
  inline void set_has_increment();
  inline void clear_has_increment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float min_phi_;
  float max_phi_;
  float min_theta_;
  float max_theta_;
  ::google::protobuf::int32 measure_delay_ms_;
  float increment_;
  friend void  protobuf_AddDesc_ScannerRpc_2eproto();
  friend void protobuf_AssignDesc_ScannerRpc_2eproto();
  friend void protobuf_ShutdownFile_ScannerRpc_2eproto();

  void InitAsDefaultInstance();
  static Request_RasterOptions* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Request_ScannerPoint ScannerPoint;
  typedef Request_RasterOptions RasterOptions;

  typedef Request_ScannerMode ScannerMode;
  static const ScannerMode IDLE = Request_ScannerMode_IDLE;
  static const ScannerMode POINT = Request_ScannerMode_POINT;
  static const ScannerMode RASTER = Request_ScannerMode_RASTER;
  static inline bool ScannerMode_IsValid(int value) {
    return Request_ScannerMode_IsValid(value);
  }
  static const ScannerMode ScannerMode_MIN =
    Request_ScannerMode_ScannerMode_MIN;
  static const ScannerMode ScannerMode_MAX =
    Request_ScannerMode_ScannerMode_MAX;
  static const int ScannerMode_ARRAYSIZE =
    Request_ScannerMode_ScannerMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ScannerMode_descriptor() {
    return Request_ScannerMode_descriptor();
  }
  static inline const ::std::string& ScannerMode_Name(ScannerMode value) {
    return Request_ScannerMode_Name(value);
  }
  static inline bool ScannerMode_Parse(const ::std::string& name,
      ScannerMode* value) {
    return Request_ScannerMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ScannerRpc.Request.ScannerMode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::ScannerRpc::Request_ScannerMode mode() const;
  inline void set_mode(::ScannerRpc::Request_ScannerMode value);

  // optional .ScannerRpc.Request.ScannerPoint set_point = 2;
  inline bool has_set_point() const;
  inline void clear_set_point();
  static const int kSetPointFieldNumber = 2;
  inline const ::ScannerRpc::Request_ScannerPoint& set_point() const;
  inline ::ScannerRpc::Request_ScannerPoint* mutable_set_point();
  inline ::ScannerRpc::Request_ScannerPoint* release_set_point();
  inline void set_allocated_set_point(::ScannerRpc::Request_ScannerPoint* set_point);

  // optional .ScannerRpc.Request.RasterOptions raster_options = 3;
  inline bool has_raster_options() const;
  inline void clear_raster_options();
  static const int kRasterOptionsFieldNumber = 3;
  inline const ::ScannerRpc::Request_RasterOptions& raster_options() const;
  inline ::ScannerRpc::Request_RasterOptions* mutable_raster_options();
  inline ::ScannerRpc::Request_RasterOptions* release_raster_options();
  inline void set_allocated_raster_options(::ScannerRpc::Request_RasterOptions* raster_options);

  // @@protoc_insertion_point(class_scope:ScannerRpc.Request)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_set_point();
  inline void clear_has_set_point();
  inline void set_has_raster_options();
  inline void clear_has_raster_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ScannerRpc::Request_ScannerPoint* set_point_;
  ::ScannerRpc::Request_RasterOptions* raster_options_;
  int mode_;
  friend void  protobuf_AddDesc_ScannerRpc_2eproto();
  friend void protobuf_AssignDesc_ScannerRpc_2eproto();
  friend void protobuf_ShutdownFile_ScannerRpc_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);

  // required string error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:ScannerRpc.Response)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* error_;
  bool success_;
  friend void  protobuf_AddDesc_ScannerRpc_2eproto();
  friend void protobuf_AssignDesc_ScannerRpc_2eproto();
  friend void protobuf_ShutdownFile_ScannerRpc_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// ===================================================================


// ===================================================================

// Request_ScannerPoint

// required double phi = 1;
inline bool Request_ScannerPoint::has_phi() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_ScannerPoint::set_has_phi() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_ScannerPoint::clear_has_phi() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_ScannerPoint::clear_phi() {
  phi_ = 0;
  clear_has_phi();
}
inline double Request_ScannerPoint::phi() const {
  // @@protoc_insertion_point(field_get:ScannerRpc.Request.ScannerPoint.phi)
  return phi_;
}
inline void Request_ScannerPoint::set_phi(double value) {
  set_has_phi();
  phi_ = value;
  // @@protoc_insertion_point(field_set:ScannerRpc.Request.ScannerPoint.phi)
}

// required double theta = 2;
inline bool Request_ScannerPoint::has_theta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_ScannerPoint::set_has_theta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_ScannerPoint::clear_has_theta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_ScannerPoint::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline double Request_ScannerPoint::theta() const {
  // @@protoc_insertion_point(field_get:ScannerRpc.Request.ScannerPoint.theta)
  return theta_;
}
inline void Request_ScannerPoint::set_theta(double value) {
  set_has_theta();
  theta_ = value;
  // @@protoc_insertion_point(field_set:ScannerRpc.Request.ScannerPoint.theta)
}

// -------------------------------------------------------------------

// Request_RasterOptions

// optional float min_phi = 1;
inline bool Request_RasterOptions::has_min_phi() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_RasterOptions::set_has_min_phi() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_RasterOptions::clear_has_min_phi() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_RasterOptions::clear_min_phi() {
  min_phi_ = 0;
  clear_has_min_phi();
}
inline float Request_RasterOptions::min_phi() const {
  // @@protoc_insertion_point(field_get:ScannerRpc.Request.RasterOptions.min_phi)
  return min_phi_;
}
inline void Request_RasterOptions::set_min_phi(float value) {
  set_has_min_phi();
  min_phi_ = value;
  // @@protoc_insertion_point(field_set:ScannerRpc.Request.RasterOptions.min_phi)
}

// optional float max_phi = 2;
inline bool Request_RasterOptions::has_max_phi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_RasterOptions::set_has_max_phi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_RasterOptions::clear_has_max_phi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_RasterOptions::clear_max_phi() {
  max_phi_ = 0;
  clear_has_max_phi();
}
inline float Request_RasterOptions::max_phi() const {
  // @@protoc_insertion_point(field_get:ScannerRpc.Request.RasterOptions.max_phi)
  return max_phi_;
}
inline void Request_RasterOptions::set_max_phi(float value) {
  set_has_max_phi();
  max_phi_ = value;
  // @@protoc_insertion_point(field_set:ScannerRpc.Request.RasterOptions.max_phi)
}

// optional float min_theta = 3;
inline bool Request_RasterOptions::has_min_theta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_RasterOptions::set_has_min_theta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_RasterOptions::clear_has_min_theta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_RasterOptions::clear_min_theta() {
  min_theta_ = 0;
  clear_has_min_theta();
}
inline float Request_RasterOptions::min_theta() const {
  // @@protoc_insertion_point(field_get:ScannerRpc.Request.RasterOptions.min_theta)
  return min_theta_;
}
inline void Request_RasterOptions::set_min_theta(float value) {
  set_has_min_theta();
  min_theta_ = value;
  // @@protoc_insertion_point(field_set:ScannerRpc.Request.RasterOptions.min_theta)
}

// optional float max_theta = 4;
inline bool Request_RasterOptions::has_max_theta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_RasterOptions::set_has_max_theta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_RasterOptions::clear_has_max_theta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_RasterOptions::clear_max_theta() {
  max_theta_ = 0;
  clear_has_max_theta();
}
inline float Request_RasterOptions::max_theta() const {
  // @@protoc_insertion_point(field_get:ScannerRpc.Request.RasterOptions.max_theta)
  return max_theta_;
}
inline void Request_RasterOptions::set_max_theta(float value) {
  set_has_max_theta();
  max_theta_ = value;
  // @@protoc_insertion_point(field_set:ScannerRpc.Request.RasterOptions.max_theta)
}

// optional int32 measure_delay_ms = 5;
inline bool Request_RasterOptions::has_measure_delay_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request_RasterOptions::set_has_measure_delay_ms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request_RasterOptions::clear_has_measure_delay_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request_RasterOptions::clear_measure_delay_ms() {
  measure_delay_ms_ = 0;
  clear_has_measure_delay_ms();
}
inline ::google::protobuf::int32 Request_RasterOptions::measure_delay_ms() const {
  // @@protoc_insertion_point(field_get:ScannerRpc.Request.RasterOptions.measure_delay_ms)
  return measure_delay_ms_;
}
inline void Request_RasterOptions::set_measure_delay_ms(::google::protobuf::int32 value) {
  set_has_measure_delay_ms();
  measure_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:ScannerRpc.Request.RasterOptions.measure_delay_ms)
}

// optional float increment = 6;
inline bool Request_RasterOptions::has_increment() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request_RasterOptions::set_has_increment() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request_RasterOptions::clear_has_increment() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request_RasterOptions::clear_increment() {
  increment_ = 0;
  clear_has_increment();
}
inline float Request_RasterOptions::increment() const {
  // @@protoc_insertion_point(field_get:ScannerRpc.Request.RasterOptions.increment)
  return increment_;
}
inline void Request_RasterOptions::set_increment(float value) {
  set_has_increment();
  increment_ = value;
  // @@protoc_insertion_point(field_set:ScannerRpc.Request.RasterOptions.increment)
}

// -------------------------------------------------------------------

// Request

// required .ScannerRpc.Request.ScannerMode mode = 1;
inline bool Request::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::ScannerRpc::Request_ScannerMode Request::mode() const {
  // @@protoc_insertion_point(field_get:ScannerRpc.Request.mode)
  return static_cast< ::ScannerRpc::Request_ScannerMode >(mode_);
}
inline void Request::set_mode(::ScannerRpc::Request_ScannerMode value) {
  assert(::ScannerRpc::Request_ScannerMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:ScannerRpc.Request.mode)
}

// optional .ScannerRpc.Request.ScannerPoint set_point = 2;
inline bool Request::has_set_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_set_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_set_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_set_point() {
  if (set_point_ != NULL) set_point_->::ScannerRpc::Request_ScannerPoint::Clear();
  clear_has_set_point();
}
inline const ::ScannerRpc::Request_ScannerPoint& Request::set_point() const {
  // @@protoc_insertion_point(field_get:ScannerRpc.Request.set_point)
  return set_point_ != NULL ? *set_point_ : *default_instance_->set_point_;
}
inline ::ScannerRpc::Request_ScannerPoint* Request::mutable_set_point() {
  set_has_set_point();
  if (set_point_ == NULL) set_point_ = new ::ScannerRpc::Request_ScannerPoint;
  // @@protoc_insertion_point(field_mutable:ScannerRpc.Request.set_point)
  return set_point_;
}
inline ::ScannerRpc::Request_ScannerPoint* Request::release_set_point() {
  clear_has_set_point();
  ::ScannerRpc::Request_ScannerPoint* temp = set_point_;
  set_point_ = NULL;
  return temp;
}
inline void Request::set_allocated_set_point(::ScannerRpc::Request_ScannerPoint* set_point) {
  delete set_point_;
  set_point_ = set_point;
  if (set_point) {
    set_has_set_point();
  } else {
    clear_has_set_point();
  }
  // @@protoc_insertion_point(field_set_allocated:ScannerRpc.Request.set_point)
}

// optional .ScannerRpc.Request.RasterOptions raster_options = 3;
inline bool Request::has_raster_options() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_raster_options() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_raster_options() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_raster_options() {
  if (raster_options_ != NULL) raster_options_->::ScannerRpc::Request_RasterOptions::Clear();
  clear_has_raster_options();
}
inline const ::ScannerRpc::Request_RasterOptions& Request::raster_options() const {
  // @@protoc_insertion_point(field_get:ScannerRpc.Request.raster_options)
  return raster_options_ != NULL ? *raster_options_ : *default_instance_->raster_options_;
}
inline ::ScannerRpc::Request_RasterOptions* Request::mutable_raster_options() {
  set_has_raster_options();
  if (raster_options_ == NULL) raster_options_ = new ::ScannerRpc::Request_RasterOptions;
  // @@protoc_insertion_point(field_mutable:ScannerRpc.Request.raster_options)
  return raster_options_;
}
inline ::ScannerRpc::Request_RasterOptions* Request::release_raster_options() {
  clear_has_raster_options();
  ::ScannerRpc::Request_RasterOptions* temp = raster_options_;
  raster_options_ = NULL;
  return temp;
}
inline void Request::set_allocated_raster_options(::ScannerRpc::Request_RasterOptions* raster_options) {
  delete raster_options_;
  raster_options_ = raster_options;
  if (raster_options) {
    set_has_raster_options();
  } else {
    clear_has_raster_options();
  }
  // @@protoc_insertion_point(field_set_allocated:ScannerRpc.Request.raster_options)
}

// -------------------------------------------------------------------

// Response

// required bool success = 1;
inline bool Response::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool Response::success() const {
  // @@protoc_insertion_point(field_get:ScannerRpc.Response.success)
  return success_;
}
inline void Response::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:ScannerRpc.Response.success)
}

// required string error = 2;
inline bool Response::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_error() {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& Response::error() const {
  // @@protoc_insertion_point(field_get:ScannerRpc.Response.error)
  return *error_;
}
inline void Response::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set:ScannerRpc.Response.error)
}
inline void Response::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set_char:ScannerRpc.Response.error)
}
inline void Response::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ScannerRpc.Response.error)
}
inline ::std::string* Response::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ScannerRpc.Response.error)
  return error_;
}
inline ::std::string* Response::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Response::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ScannerRpc.Response.error)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ScannerRpc

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ScannerRpc::Request_ScannerMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ScannerRpc::Request_ScannerMode>() {
  return ::ScannerRpc::Request_ScannerMode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ScannerRpc_2eproto__INCLUDED
